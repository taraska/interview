Задача нахождения кратчайшего пути в графе — это классическая задача,
которая часто решается с использованием алгоритмов, таких как алгоритм
Дейкстры (для графов с неотрицательными весами) или алгоритм Беллмана-Форда
(для графов с отрицательными весами). В этом примере мы рассмотрим реализацию
алгоритма Дейкстры на Java.

Задача:
Дан взвешенный граф с неотрицательными весами рёбер. Необходимо найти кратчайший путь
от заданной начальной вершины до всех остальных вершин.

Пример графа:
Copy
Вершины: 0, 1, 2, 3, 4
Рёбра:
0 -> 1 (вес 4)
0 -> 2 (вес 1)
1 -> 3 (вес 1)
2 -> 1 (вес 2)
2 -> 3 (вес 5)
3 -> 4 (вес 3)


Объяснение кода:
Граф представлен списком смежности:
Каждая вершина хранит список своих соседей с указанием веса рёбер.
Алгоритм Дейкстры:
Используется массив distances для хранения кратчайших расстояний от начальной
вершины до всех остальных.
Приоритетная очередь (PriorityQueue) выбирает вершину с минимальным расстоянием
на каждом шаге.
Для каждой вершины обновляются расстояния до её соседей, если найден более короткий
путь.
Вывод результатов:
После завершения алгоритма выводится массив distances, содержащий кратчайшие расстояния
от начальной вершины до всех остальных.

Пример вывода:
Для графа, описанного выше, вывод будет следующим:
Copy
Кратчайшие расстояния от вершины 0:
До вершины 0: 0
До вершины 1: 3
До вершины 2: 1
До вершины 3: 4
До вершины 4: 7

Временная сложность:
O((V + E) log V), где:
V — количество вершин.
E — количество рёбер.
Это связано с использованием приоритетной очереди.

Дополнительные улучшения:
Поддержка отрицательных весов:
Если в графе есть отрицательные веса, используйте алгоритм Беллмана-Форда.
Восстановление пути:
Добавьте массив previous[], чтобы хранить предыдущую вершину для каждой вершины.
Это позволит восстановить путь от начальной вершины до любой другой.
Оптимизация для плотных графов:
Если граф плотный, можно использовать реализацию с обычной очередью и поиском
минимума за O(V).

Итог:
Алгоритм Дейкстры эффективно решает задачу поиска кратчайшего пути в графе с
неотрицательными весами. Реализация на Java с использованием приоритетной
очереди проста и понятна.
